// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: agent_states.sql

package dbaccess

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAgentState = `-- name: CreateAgentState :exec
INSERT INTO agent_states (agent_id, state, status, role, awakened_at, asleep_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateAgentStateParams struct {
	AgentID    string
	State      []byte
	Status     string
	Role       string
	AwakenedAt pgtype.Timestamp
	AsleepAt   pgtype.Timestamp
}

func (q *Queries) CreateAgentState(ctx context.Context, arg CreateAgentStateParams) error {
	_, err := q.db.Exec(ctx, createAgentState,
		arg.AgentID,
		arg.State,
		arg.Status,
		arg.Role,
		arg.AwakenedAt,
		arg.AsleepAt,
	)
	return err
}

const getAgentState = `-- name: GetAgentState :one
SELECT id, agent_id, status, role, state, created_at, updated_at, awakened_at, asleep_at
FROM agent_states
WHERE agent_id = $1
`

func (q *Queries) GetAgentState(ctx context.Context, agentID string) (AgentState, error) {
	row := q.db.QueryRow(ctx, getAgentState, agentID)
	var i AgentState
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.Status,
		&i.Role,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AwakenedAt,
		&i.AsleepAt,
	)
	return i, err
}

const searchAgentByAsleepDurationAndStatus = `-- name: SearchAgentByAsleepDurationAndStatus :many
SELECT id, agent_id, status, role, state, created_at, updated_at, awakened_at, asleep_at
FROM agent_states
WHERE asleep_at + $1::interval < now()
  AND status = ANY($2::varchar[])
ORDER BY asleep_at ASC
LIMIT $3
`

type SearchAgentByAsleepDurationAndStatusParams struct {
	Duration  pgtype.Interval
	Statuses  []string
	MaxAgents int32
}

func (q *Queries) SearchAgentByAsleepDurationAndStatus(ctx context.Context, arg SearchAgentByAsleepDurationAndStatusParams) ([]AgentState, error) {
	rows, err := q.db.Query(ctx, searchAgentByAsleepDurationAndStatus, arg.Duration, arg.Statuses, arg.MaxAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentState
	for rows.Next() {
		var i AgentState
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.Status,
			&i.Role,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AwakenedAt,
			&i.AsleepAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAgentByAwakeDurationAndStatus = `-- name: SearchAgentByAwakeDurationAndStatus :many
SELECT id, agent_id, status, role, state, created_at, updated_at, awakened_at, asleep_at
FROM agent_states
WHERE awakened_at + $1::interval < now()
  AND status = ANY($2::varchar[])
ORDER BY awakened_at ASC
LIMIT $3
`

type SearchAgentByAwakeDurationAndStatusParams struct {
	Duration  pgtype.Interval
	Statuses  []string
	MaxAgents int32
}

func (q *Queries) SearchAgentByAwakeDurationAndStatus(ctx context.Context, arg SearchAgentByAwakeDurationAndStatusParams) ([]AgentState, error) {
	rows, err := q.db.Query(ctx, searchAgentByAwakeDurationAndStatus, arg.Duration, arg.Statuses, arg.MaxAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentState
	for rows.Next() {
		var i AgentState
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.Status,
			&i.Role,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AwakenedAt,
			&i.AsleepAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAgentByStatus = `-- name: SearchAgentByStatus :many
SELECT id, agent_id, status, role, state, created_at, updated_at, awakened_at, asleep_at
FROM agent_states
WHERE status = $1
`

func (q *Queries) SearchAgentByStatus(ctx context.Context, status string) ([]AgentState, error) {
	rows, err := q.db.Query(ctx, searchAgentByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentState
	for rows.Next() {
		var i AgentState
		if err := rows.Scan(
			&i.ID,
			&i.AgentID,
			&i.Status,
			&i.Role,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AwakenedAt,
			&i.AsleepAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAgentState = `-- name: UpdateAgentState :exec
UPDATE agent_states
SET state = $1, status = $2, role = $3, awakened_at = $4, asleep_at = $5
WHERE agent_id = $6
`

type UpdateAgentStateParams struct {
	State      []byte
	Status     string
	Role       string
	AwakenedAt pgtype.Timestamp
	AsleepAt   pgtype.Timestamp
	AgentID    string
}

func (q *Queries) UpdateAgentState(ctx context.Context, arg UpdateAgentStateParams) error {
	_, err := q.db.Exec(ctx, updateAgentState,
		arg.State,
		arg.Status,
		arg.Role,
		arg.AwakenedAt,
		arg.AsleepAt,
		arg.AgentID,
	)
	return err
}
